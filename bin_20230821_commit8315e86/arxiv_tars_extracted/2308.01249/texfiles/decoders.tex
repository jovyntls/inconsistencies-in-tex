\section{Semi-joint Decoder Variants}
In this section, we first introduce the semi-joint (SJ) decoder and its variants. The SJ decoder is equivalent to the SG decoder from~\cite{9594186,9174265}, extended to communications over general channels. %

\vspace*{0.8ex}
\noindent\emph{SJ Decoder (Conventional SG Decoder)~\cite{8625294}} \\
In SJ decoding, we decode a specific \emph{target} sub-block $T$ with the help of $d$ neighboring sub-blocks, called \emph{helpers}. We assume that the number of involved sub-blocks does not exceed the total number of the sub-blocks and we neglect boundary effects. Furthermore, we assume $d$ to be even, so that the helpers lie symmetrically on both sides of the target. The decoder is described by:\vspace{0.2ex}

\begin{enumerate}
    \item Decode the two furthest sub-blocks $T+\frac d2$ and $\ T-\frac d2$ locally, i.e. carry out BP decoding using the LCs only (effectively using a parity-check matrix $\Blocal$) using the sub-block channel outputs $\boldsymbol{y}_{T- d/2}$ and $\boldsymbol{y}_{T+d/2}$, respectively.
    \item Decode the left helpers: for the $i$-th helper, $T- \frac d2 < i < T$, decode the sub-block with information from its left neighbor, i.e. carry out BP decoding with the parity check matrix $\left[\begin{matrix}\Bright & \Bleft \\ \boldsymbol{0} & \Blocal\end{matrix}\right]$ and $[\hat{\boldsymbol{y}}_{i-1},\ \boldsymbol{y}_i]$, with $\hat{\boldsymbol{y}}_{i-1}$ the updated information of the left neighbor.
    \item Decode the right helpers: for the $i$-th helper, $T<i<T+\frac d2$, decode the sub-block with information from its right neighbor, i.e. do BP decoding with the parity check matrix $\left[\begin{matrix}\Blocal & \boldsymbol{0} \\ \Bright & \Bleft \end{matrix}\right]$ and $[\boldsymbol{y}_i, \hat{\boldsymbol{y}}_{i+1}]$, where $\hat{\boldsymbol{y}}_{i+1}$ is the updated information of the right neighbor.
    \item Decode the target: carry out BP decoding with the parity check matrix $\left[\begin{matrix}\Bright & \Bleft & \boldsymbol{0} \\ \boldsymbol{0} & \Blocal & \boldsymbol{0} \\\boldsymbol{0} & \Bright & \Bleft \end{matrix}\right]$ and $[\hat{\boldsymbol{y}}_{T-1},\ \boldsymbol{y}_T,\ \hat{\boldsymbol{y}}_{T+1}]$.
\end{enumerate}

It should be noted that the decoding of helpers on both sides can be carried out in parallel. In Figs.~\ref{figure_comparison_sg_var1} and \ref{figure_comparison_sg_var2}, the performance of our exemplary code under SJ decoding is given together with the separate and fully joint decoding performance as reference. An increasing number of helpers leads to lower bit error rates (BERs); separate and fully joint decoding are lower and upper bound on the SJ decoding performance. We can see that already for small $d$, SJ decoding closes the significant gap between joint and separate decoding, the latter effectively using a code of higher rate but with complete separate decoders.

\vspace*{0.8ex}
\noindent\emph{SJ Decoder Variant} \\
As stated before, the information flow between the decoder in SJ decoding is an important performance parameter, especially if the decoder are realized in different circuits. In the SJ decoder, we exchange $d$ times  soft information between sub-blocks for decoding a single sub-block. In this variant, we exploit that in an SDM system, the channel information from different sub-channels is available at the same time. The proposed variant is described in what follows:

\begin{enumerate}
    \item For decoding target sub-block $T$, the helpers $T-\frac d2, \dots, T-1$ and $T+1, \dots, T+\frac d2$ transmit their channel information to the target.
    \item Carry out BP decoding using the parity check matrix
    \[
    \boldsymbol{B} = \underbrace{\left[\begin{matrix}
        \Blocal &         &         &         &   \\
        \Bright & \Bleft  &         &         &   \\
                & \Blocal &         &         &   \\
                & \Bright &         &         &   \\
                &         & \ddots  &         &   \\
                &         &         & \Bright & \Bleft \\
                &         &         &         & \Blocal \\
    \end{matrix}\right]}_{d+1 \text{ sub-blocks}}
    \]
    and the channel information
    \[
    [\boldsymbol{y}_{T-\frac d2}, \dots, \boldsymbol{y}_{T-1}, \boldsymbol{y}_T, \boldsymbol{y}_{T+1}, \dots, \boldsymbol{y}_{T+\frac d2}].
    \]
\end{enumerate}
It is easy to show that the complexity of this approach is identical to the SJ decoder and the different decoders only need to exchange information before starting decoding and not during the execution of the decoder. The performance of our example code using the new decoder variant (denoted ``SJVar'') is shown in Fig.~\ref{figure_comparison_sg_var1}. With the same number of helpers $d$, our new variant provides a performance gain of approximately $0.2\mathrm{dB}$, without increasing the information flow between the sub-blocks and the complexity of the decoder.

\begin{figure}[t]
    \input{figures/comparison_sg_var1.tex} 
    \caption{Performance of $(\dv=4, \dc=20, t=\frac14)$ code under SJ decoding and the proposed variant}
    \label{figure_comparison_sg_var1}
\end{figure}

\vspace*{0.8ex}
\noindent\emph{SJ Decoding with Hard Information Exchange} \\
In both the SJ decoder and the variant, we exchange soft information between the sub-blocks. Soft information is usually quantized using $q$ bits (typically $q = 5,\ldots, 7$). Exchanging hard information significantly reduces the information flow in the system by a factor of $q$. Therefore, we propose a SJ decoder variant, denoted ``SJ-HD'', which allows hard information exchange while degrading the performance only slightly. The idea is that after BP decoding of a helper, the hard decisions of the variable nodes are transmitted along with an estimate $\hat{\delta}_{\mathrm{b}}$ of the BER. Ther BER estimate is obtained from the fraction $\delta_{\mathrm{c}}$  of unfulfilled check equations through
\begin{equation}
    \hat{\delta}_{\mathrm{b}} = \frac12\left(1-\left(1-2\delta_{\mathrm{c}}\right)^{\frac 1\dc}\right)\,.
    \label{equ_BER_estimate}
\end{equation}
The hard decision of the helper $\hat{\boldsymbol{x}}$ and the corresponding BER are then used to calculate soft information (in terms of log-likelihood ratios (LLRs)) for the next stage (next helper or final decoder) via $\boldsymbol{y}=\hat{\boldsymbol{x}}\cdot\ln\left(\frac{1-\hat{\delta}_{\mathrm{b}}}{\hat{\delta}_{\mathrm{b}}}\right)$. 
We compare the the decoding performance with conventional SJ decoding in Fig.~\ref{figure_comparison_sg_var2}. We observe that the reduction of information flow towards hard decision by a factor $q$ is achieved at the cost of only around 0.1\,dB in BER, which offers a reasonable trade-off between information flow and decoding performance.

\begin{figure}[t]
    \input{figures/comparison_sg_var2.tex} 
    \caption{Performance of $(\dv=4, \dc=20, t=\frac14)$ code SJ and HD-SJ decoding}
    \label{figure_comparison_sg_var2}
\end{figure}

Unfortunately, both variants cannot be trivially combined as the SJ decoder uses soft information to get an estimate of the local symbols, while the variant uses soft information from the beginning.